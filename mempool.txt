### MEMPOOL
    #1. 内存管理
        内存管理堪称一道至关重要却又布满荆棘的关卡，传统的 C++ 内存管理方式，如使用new和delete操作符，
        看似简单直接，实则暗藏隐患。在程序频繁地进行内存分配与释放操作时，就如同在一块原本平整的土地上
        随意地挖坑、填坑，久而久之，土地变得坑洼不平，碎片化严重。这不仅导致内存空间的浪费，还使得后续
        的内存分配操作变得困难重重，就像在崎岖的山路上寻找一块合适的平地建房一样，效率极低。

    #2. 内存池介绍
        内存池是一种内存分配方式，又被称为固定大小区块规划，通常我们习惯直接使用new、malloc等API申请分
        配内存，这样做的缺点在于：由于所申请内存块的大小不定，当频繁使用时会造成大量的内存碎片并进而降低性能。
        
        #1  内存碎片问题
            造成堆利用率很低的一个主要原因就是内存碎片化。内存碎片化分为内部碎片和外部碎片。
            内碎片：内部碎片是指一个已分配的块比有效载荷大时发生的。(假设以前分配了10个大小的字节，现在
                    只用了5个字节，则剩下的5个字节就会内碎片)。内部碎片的大小就是已经分配的块的大小和他
                    们的有效载荷之差的和。
            外碎片：假设系统依次分配了16byte、8byte、16byte、4byte，还剩余8byte未分配。这时要分配一个24
                    byte的空间，操作系统回收了一个上面的两个16byte，总的剩余空间有40byte，但是却不能分配
                    出一个连续24byte的空间。

        #2 内存池原理
            内存池的思想在真正使用内存之前，预先申请分配一定数量、大小预设的内存块留作备用。当有新的内存
            求时，就从内存池中分出一部分内存块，若内存块不够再继续申请新的内存，当内存释放后就回归到内存
            块留作后续的复用，使得内存使用效率得到提升，一般也不会产生不可控制的内存碎片。
        
        #3 内存池设计算法原理：   
            预申请一个内存区chunk，将内存中按照对象大小划分成多个内存块block
            维持一个空闲内存块链表，通过指针相连，标记头指针为第一个空闲块
            每次新申请一个对象的空间，则将该内存块从空闲链表中去除，更新空闲链表头指针
            每次释放一个对象的空间，则重新将该内存块加到空闲链表头
            如果一个内存区占满了，则新开辟一个内存区，维持一个内存区的链表，同指针相连，头指针指向最新的
            内存区，新的内存块从该区内重新划分和申请。  
        
        #4 内存池分类
            内存池可以分为不定长内存池和定长内存池两类。
            不定长内存池的典型实现包括Apache Portable Runtime中的apr_pool和GNU lib C中的obstack，
            而定长内存池的实现则有boost_pool等。

            对于不定长内存池，不需要为不同的数据类型创建不同的内存池，其缺点是无法将分配出的内存回收
            到池内；

            对于定长内存池，在使用完毕后，可以将内存归还到内存池中，但需要为不同类型的数据结构创建不
            同的内存池，需要内存的时候要从相应的内存池中申请内存。

    #3 内存池解决哪些问题
        解决内碎片问题
        由于向内存申请的内存块都是比较大的，所以能够降低外碎片问题
        一次性向内存申请一块大的内存慢慢使用，避免了频繁的向内存请求内存操作，提高内存分配的效率
        但是内碎片问题无法避免，只能尽可能的降低

    #4 内存池演变
        最简单的内存分配器，做一个链表指向空闲内存，分配就是取出一块来，改写链表，返回，释放就是放回到链表
        里面，并做好归并。注意做好标记和保护，避免二次释放，还可以花点力气在如何查找最适合大小的内存快的搜
        索上，减少内存碎片，有空你了还可以把链表换成伙伴算法。

        优点： 实现简单
        缺点： 分配时搜索合适的内存块效率低，释放回归内存后归并消耗大，实际中不实用。

        定长内存分配器，即实现一个 FreeList，每个 FreeList 用于分配固定大小的内存块，比如用于分配32字节
        对象的固定内存分配器之类的。每个固定内存分配器里面有两个链表，OpenList 用于存储未分配的空闲对象，
        CloseList用于存储已分配的内存对象，那么所谓的分配就是从 OpenList 中取出一个对象放到 CloseList 里
        并且返回给用户，释放又是从 CloseList 移回到 OpenList。分配时如果不够，那么就需要增长 OpenList：
        申请一个大一点的内存块，切割成比如 64 个相同大小的对象添加到 OpenList中。这个固定内存分配器回收的
        时候，统一把先前向系统申请的内存块全部还给系统。

        优点： 简单粗暴，分配和释放的效率高，解决实际中特定场景下的问题有效。
        缺点： 功能单一，只能解决定长的内存需求，另外占着内存没有释放。
    
    #5 malloc 底层原理
        C 标准库函数malloc 在底层使用的是 —– 分离适配，使用这种方法，分配器维护着一个空闲链表数组，
        每个空闲链表被组织成某种类型的显示/隐式链表。每个链表包含大小不同的块，这些块的大小是大小类
        的成员，当要分配一个块时，我们确定了大小类之后，对适当的空闲链表做首次适配，查找一个合适的块，
        如果找到，那么可选地分割它，并将剩余的部分插入到适当的空闲链表中。如果每找到，那就搜索下一个
        更大的大小类的空闲链表，重复直到找到一个合适的块。如果空闲链表中没有合适的块，那么就向操作系
        统请求额外的堆存储器，从这个新的堆存储器中分配一个块，将剩余部分放置在适当的大小类中，当释放
        一个块时，我们执行合并，并将结果放在相应的空闲链表中。

    固定内存池，正如其名，每次从内存池中分配出来的内存单元大小是固定不变的。在程序初始化时，就预先设定
        好内存块的大小。例如，我们创建一个用于管理小型数据结构（如链表节点）的固定内存池，每个内存块大小设
        为 32 字节。当程序需要创建链表节点时，直接从这个内存池中获取 32 字节的内存块，无需再向操作系统申请。

        固定内存池的优点十分显著。由于内存块大小固定，其分配和释放操作非常高效，就像在一个装满同样大小盒子
        的仓库里取放物品，无需挑选和测量，直接拿取或放回即可。而且，因为内存块大小一致，在分配和回收过程中
        不会产生不同大小的内存空洞，能够有效减少内存碎片，提高内存利用率。在游戏开发中，大量的游戏对象（如
        子弹、怪物等）具有相同的大小和结构，使用固定内存池来管理这些对象的内存分配，可以显著提升游戏的性能
        和稳定性。